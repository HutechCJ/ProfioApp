"use strict";(self.webpackChunk_profio_app_source=self.webpackChunk_profio_app_source||[]).push([[58],{3905:(e,t,i)=>{i.d(t,{Zo:()=>d,kt:()=>h});var a=i(7294);function r(e,t,i){return t in e?Object.defineProperty(e,t,{value:i,enumerable:!0,configurable:!0,writable:!0}):e[t]=i,e}function o(e,t){var i=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),i.push.apply(i,a)}return i}function n(e){for(var t=1;t<arguments.length;t++){var i=null!=arguments[t]?arguments[t]:{};t%2?o(Object(i),!0).forEach((function(t){r(e,t,i[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(i)):o(Object(i)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(i,t))}))}return e}function s(e,t){if(null==e)return{};var i,a,r=function(e,t){if(null==e)return{};var i,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)i=o[a],t.indexOf(i)>=0||(r[i]=e[i]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)i=o[a],t.indexOf(i)>=0||Object.prototype.propertyIsEnumerable.call(e,i)&&(r[i]=e[i])}return r}var l=a.createContext({}),c=function(e){var t=a.useContext(l),i=t;return e&&(i="function"==typeof e?e(t):n(n({},t),e)),i},d=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},p="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var i=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=c(i),m=r,h=p["".concat(l,".").concat(m)]||p[m]||u[m]||o;return i?a.createElement(h,n(n({ref:t},d),{},{components:i})):a.createElement(h,n({ref:t},d))}));function h(e,t){var i=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=i.length,n=new Array(o);n[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[p]="string"==typeof e?e:r,n[1]=s;for(var c=2;c<o;c++)n[c]=i[c];return a.createElement.apply(null,n)}return a.createElement.apply(null,i)}m.displayName="MDXCreateElement"},9643:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>h,frontMatter:()=>s,metadata:()=>c,toc:()=>p});var a=i(7462),r=i(3366),o=(i(7294),i(3905)),n=["components"],s={title:"Building Blocks",description:"A brief description of the building blocks",sidebar_position:1,last_update:{author:"Nguyen Xuan Nhan"}},l=void 0,c={unversionedId:"system-design/buildingblock",id:"system-design/buildingblock",title:"Building Blocks",description:"A brief description of the building blocks",source:"@site/docs/system-design/buildingblock.md",sourceDirName:"system-design",slug:"/system-design/buildingblock",permalink:"/ProfioApp/docs/system-design/buildingblock",draft:!1,editUrl:"https://github.com/HutechCJ/ProfioApp/blob/main/apps/docs/docs/system-design/buildingblock.md",tags:[],version:"current",lastUpdatedBy:"Nguyen Xuan Nhan",lastUpdatedAt:1696419484,formattedLastUpdatedAt:"Oct 4, 2023",sidebarPosition:1,frontMatter:{title:"Building Blocks",description:"A brief description of the building blocks",sidebar_position:1,last_update:{author:"Nguyen Xuan Nhan"}},sidebar:"tutorialSidebar",previous:{title:"System Design",permalink:"/ProfioApp/docs/category/system-design"},next:{title:"C4 Model",permalink:"/ProfioApp/docs/system-design/c4"}},d={},p=[{value:"Components",id:"components",level:2},{value:"CMS:",id:"cms",level:3},{value:"Customer Website:",id:"customer-website",level:3},{value:"Load Balancer:",id:"load-balancer",level:3},{value:"Driver App:",id:"driver-app",level:3},{value:"MQTT Broker:",id:"mqtt-broker",level:3},{value:"Identity Server:",id:"identity-server",level:3},{value:"API Server:",id:"api-server",level:3},{value:"Database:",id:"database",level:3},{value:"OpenTelemetry Collector:",id:"opentelemetry-collector",level:3},{value:"Health Check:",id:"health-check",level:3},{value:"Exporter:",id:"exporter",level:3},{value:"API Architecture &amp; Patterns",id:"api-architecture--patterns",level:2},{value:"Clean Architecture",id:"clean-architecture",level:3},{value:"Design Patterns",id:"design-patterns",level:3},{value:"Communication Protocols",id:"communication-protocols",level:2},{value:"HTTP",id:"http",level:3},{value:"MQTT",id:"mqtt",level:3},{value:"OTLP",id:"otlp",level:3}],u={toc:p},m="wrapper";function h(e){var t=e.components,s=(0,r.Z)(e,n);return(0,o.kt)(m,(0,a.Z)({},u,s,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("img",{loading:"lazy",src:i(1489).Z,alt:"Profio Introduction",style:{width:"100%",height:"auto"}}),(0,o.kt)("h2",{id:"components"},"Components"),(0,o.kt)("h3",{id:"cms"},"CMS:"),(0,o.kt)("p",{align:"justify"},(0,o.kt)("p",null,"This component serves as a central hub for managing information related to transportation processes. It likely includes features such as order management, vehicle tracking, and driver information management. The CMS also provides a dashboard for managers to monitor and oversee the entire transportation process. This dashboard may display real-time data, analytics, and reports to help managers make informed decisions. Next.js is a web framework used to develop the CMS. It's a React-based framework that allows for the creation of dynamic web pages. It's also a popular choice for building server-side rendered applications.")),(0,o.kt)("h3",{id:"customer-website"},"Customer Website:"),(0,o.kt)("p",{align:"justify"},(0,o.kt)("p",null,"Customers can use this website to look up information about their orders, and there's also a feature to view the history of their previous orders. This website is built using Blazor Server, which is a web framework for building interactive web UIs using C# instead of JavaScript. It's a popular choice for building server-side rendered applications.")),(0,o.kt)("h3",{id:"load-balancer"},"Load Balancer:"),(0,o.kt)("p",{align:"justify"},(0,o.kt)("p",null,"YARP, or Yet Another Reverse Proxy, serves as a load balancer. It distributes incoming network traffic across multiple servers to ensure efficient utilization and prevent overloading. The Load Balancer also provides a dashboard for managers to monitor the load on the servers. This allows them to optimize resource allocation.")),(0,o.kt)("h3",{id:"driver-app"},"Driver App:"),(0,o.kt)("p",{align:"justify"},(0,o.kt)("p",null,"The Driver App is a mobile application developed using the Flutter framework. It's intended for drivers to monitor the transportation process. One of its primary functions is to send the real-time location of vehicles to the central server, likely using GPS or other location services.")),(0,o.kt)("h3",{id:"mqtt-broker"},"MQTT Broker:"),(0,o.kt)("p",{align:"justify"},(0,o.kt)("p",null,"EMQX serves as an MQTT broker, which is a messaging protocol often used for IoT and real-time data communication. In this context, it receives vehicle location data from the Driver App and forwards it to the server for further processing. We have integrated EMQX with the Redis database to store the location data for later retrieval.")),(0,o.kt)("h3",{id:"identity-server"},"Identity Server:"),(0,o.kt)("p",{align:"justify"},(0,o.kt)("p",null,"Keycloak is an identity and access management system used for user authentication and authorization. It manages user accounts for your application and provides Single Sign-On (SSO) capabilities, making it convenient for users to access various parts of the system without repeated logins.")),(0,o.kt)("h3",{id:"api-server"},"API Server:"),(0,o.kt)("p",{align:"justify"},(0,o.kt)("p",null,"The API Server is the core of your system for handling data transmission. It receives vehicle location data from the MQTT Broker and interacts with the database. It also serves as the interface for clients (such as the Next.js customer website) to access information about orders, vehicles, drivers, and other transportation-related data.")),(0,o.kt)("h3",{id:"database"},"Database:"),(0,o.kt)("p",{align:"justify"},(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"PostgreSQL is used as the primary database to store structured data related to orders, vehicles, drivers, and transportation processes. It's also used for storing user accounts and other information related to the Identity Server. Database Replication is used to improve performance and reliability by distributing data across multiple servers."),(0,o.kt)("li",{parentName:"ul"},"Redis, on the other hand, is utilized for caching data, which can improve system performance by reducing the need to retrieve data from the database repeatedly. With High Availability, Redis can also be used as a backup database in case of a database failure."))),(0,o.kt)("h3",{id:"opentelemetry-collector"},"OpenTelemetry Collector:"),(0,o.kt)("p",{align:"justify"},(0,o.kt)("p",null,"This component collects telemetry data from various parts of your system, including applications and services. It's responsible for forwarding this telemetry data to processing and monitoring tools for analysis, diagnostics, and performance optimization.")),(0,o.kt)("h3",{id:"health-check"},"Health Check:"),(0,o.kt)("p",{align:"justify"},(0,o.kt)("p",null,"The Health Check component continuously monitors the health of your servers and services. It reports the health status to the Load Balancer, allowing it to make informed decisions about routing traffic to healthy servers.")),(0,o.kt)("h3",{id:"exporter"},"Exporter:"),(0,o.kt)("p",{align:"justify"},(0,o.kt)("p",null,"These are various monitoring and analysis tools used to export and visualize telemetry data collected by the OpenTelemetry Collector.\nGrafana, Prometheus, Jaeger, Seq, and Zipkin are commonly used tools in the DevOps and observability space.")),(0,o.kt)("h2",{id:"api-architecture--patterns"},"API Architecture & Patterns"),(0,o.kt)("h3",{id:"clean-architecture"},"Clean Architecture"),(0,o.kt)("img",{loading:"lazy",src:i(8473).Z,alt:"Clean Architecture",style:{width:"100%",height:"auto"}}),(0,o.kt)("p",{align:"justify"},"Clean Architecture is a software design principle that emphasizes organizing code in a way that separates concerns, making it easier to maintain and test. It divides an application into distinct layers: the Core (containing business logic and entities), Use Cases (defining application-specific rules), Interface Adapters (connecting to the outside world), and Frameworks/Drivers (external dependencies). This separation allows for flexibility, testability, and maintainability, reducing the risk of unintended side effects when making changes. Clean Architecture promotes robust and adaptable software systems."),(0,o.kt)("h3",{id:"design-patterns"},"Design Patterns"),(0,o.kt)("img",{loading:"lazy",src:i(7783).Z,alt:"CQRS and Mediator Pattern",style:{width:"100%",height:"auto"}}),(0,o.kt)("p",{align:"justify"},"CQRS (Command Query Responsibility Segregation) is a software design pattern that separates the read and write operations of a system into two distinct models. The Command model handles write operations, while the Query model handles read operations. This separation allows for the optimization of each model for its specific purpose, improving performance and scalability. The Mediator Pattern is used to implement CQRS, decoupling the Command and Query models and enabling communication between them. The Mediator Pattern also allows for the addition of new handlers without modifying existing handlers, improving the system's flexibility and maintainability."),(0,o.kt)("p",null,"We have also implemented the following design patterns:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Repository Pattern"),(0,o.kt)("li",{parentName:"ul"},"Unit of Work"),(0,o.kt)("li",{parentName:"ul"},"Specification Pattern"),(0,o.kt)("li",{parentName:"ul"},"Options Pattern"),(0,o.kt)("li",{parentName:"ul"},"Inversion of Control / Dependency Injection")),(0,o.kt)("h2",{id:"communication-protocols"},"Communication Protocols"),(0,o.kt)("h3",{id:"http"},"HTTP"),(0,o.kt)("p",{align:"justify"},"Client-server communication is handled using the HTTP protocol. HTTP is a widely used application-layer protocol for transmitting data between clients and servers. It is a stateless protocol, meaning that each request is independent of the previous request. HTTP is a reliable and efficient protocol for client-server communication."),(0,o.kt)("h3",{id:"mqtt"},"MQTT"),(0,o.kt)("p",{align:"justify"},"The GPS tracking functionality is implemented using the MQTT protocol. MQTT is a lightweight messaging protocol designed for IoT devices. It is a publish-subscribe protocol, meaning that clients can subscribe to topics and receive messages published to those topics. MQTT is a reliable and efficient protocol for real-time communication."),(0,o.kt)("h3",{id:"otlp"},"OTLP"),(0,o.kt)("p",{align:"justify"},"The OpenTelemetry Protocol (OTLP) is used for transmitting observability data. OTLP is a protocol for transmitting telemetry data, including traces, metrics, and logs. OTLP is a reliable and efficient protocol for transmitting observability data."))}h.isMDXComponent=!0},1489:(e,t,i)=>{i.d(t,{Z:()=>a});const a=i.p+"assets/images/building-blocks-bd495257542d67e3fd2c0786999e5b89.png"},8473:(e,t,i)=>{i.d(t,{Z:()=>a});const a=i.p+"assets/images/clean-3851158fe730be214a966848155f6bd7.png"},7783:(e,t,i)=>{i.d(t,{Z:()=>a});const a=i.p+"assets/images/cqrs-6531b64ac9e253359f083818187d903c.png"}}]);